{"ast":null,"code":"var stemmer = require('../stemmer'),\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\",\n    vowels = \"aeiouy\",\n    consonants = alphabet.replace(RegExp(\"[\" + vowels + \"]\", \"g\"), \"\") + \"Y\",\n    v_wxy = vowels + \"wxY\",\n    valid_li = \"cdeghkmnrt\",\n    r1_re = RegExp(\"^.*?([\" + vowels + \"][^\" + vowels + \"]|$)\"),\n    r1_spec = /^(gener|commun|arsen)/,\n    doubles = /(bb|dd|ff|gg|mm|nn|pp|rr|tt)$/,\n    y_cons = RegExp(\"([\" + vowels + \"])y\", \"g\"),\n    y_suff = RegExp(\"(.[^\" + vowels + \"])[yY]$\"),\n    exceptions1 = {\n  skis: \"ski\",\n  skies: \"sky\",\n  dying: \"die\",\n  lying: \"lie\",\n  tying: \"tie\",\n  idly: \"idl\",\n  gently: \"gentl\",\n  ugly: \"ugli\",\n  early: \"earli\",\n  only: \"onli\",\n  singly: \"singl\",\n  sky: \"sky\",\n  news: \"news\",\n  howe: \"howe\",\n  atlas: \"atlas\",\n  cosmos: \"cosmos\",\n  bias: \"bias\",\n  andes: \"andes\"\n},\n    exceptions2 = [\"inning\", \"outing\", \"canning\", \"herring\", \"earring\", \"proceed\", \"exceed\", \"succeed\"];\n\nmodule.exports = function (word) {\n  // Exceptions 1\n  var stop = stemmer.except(word, exceptions1);\n  if (stop) return stop; // No stemming for short words.\n\n  if (word.length < 3) return word; // Y = \"y\" as a consonant.\n\n  if (word[0] === \"y\") word = \"Y\" + word.substr(1);\n  word = word.replace(y_cons, \"$1Y\"); // Identify the regions of the word.\n\n  var r1, m;\n\n  if (m = r1_spec.exec(word)) {\n    r1 = m[0].length;\n  } else {\n    r1 = r1_re.exec(word)[0].length;\n  }\n\n  var r2 = r1 + r1_re.exec(word.substr(r1))[0].length; // Step 0\n\n  word = word.replace(/^'/, \"\");\n  word = word.replace(/'(s'?)?$/, \"\"); // Step 1a\n\n  word = stemmer.among(word, [\"sses\", \"ss\", \"(ied|ies)\", function (match, _, offset) {\n    return offset > 1 ? \"i\" : \"ie\";\n  }, \"([\" + vowels + \"].*?[^us])s\", function (match, m1) {\n    return m1;\n  }]);\n  stop = stemmer.except(word, exceptions2);\n  if (stop) return stop; // Step 1b\n\n  word = stemmer.among(word, [\"(eed|eedly)\", function (match, _, offset) {\n    return offset >= r1 ? \"ee\" : match + \" \";\n  }, \"([\" + vowels + \"].*?)(ed|edly|ing|ingly)\", function (match, prefix, suffix, off) {\n    if (/(?:at|bl|iz)$/.test(prefix)) {\n      return prefix + \"e\";\n    } else if (doubles.test(prefix)) {\n      return prefix.substr(0, prefix.length - 1);\n    } else if (shortv(word.substr(0, off + prefix.length)) && off + prefix.length <= r1) {\n      return prefix + \"e\";\n    } else {\n      return prefix;\n    }\n  }]); // Step 1c\n\n  word = word.replace(y_suff, \"$1i\"); // Step 2\n\n  word = stemmer.among(word, r1, [\"(izer|ization)\", \"ize\", \"(ational|ation|ator)\", \"ate\", \"enci\", \"ence\", \"anci\", \"ance\", \"abli\", \"able\", \"entli\", \"ent\", \"tional\", \"tion\", \"(alism|aliti|alli)\", \"al\", \"fulness\", \"ful\", \"(ousli|ousness)\", \"ous\", \"(iveness|iviti)\", \"ive\", \"(biliti|bli)\", \"ble\", \"ogi\", function (m, off) {\n    return word[off - 1] === \"l\" ? \"og\" : \"ogi\";\n  }, \"fulli\", \"ful\", \"lessli\", \"less\", \"li\", function (m, off) {\n    return ~valid_li.indexOf(word[off - 1]) ? \"\" : \"li\";\n  }]); // Step 3\n\n  word = stemmer.among(word, r1, [\"ational\", \"ate\", \"tional\", \"tion\", \"alize\", \"al\", \"(icate|iciti|ical)\", \"ic\", \"(ful|ness)\", \"\", \"ative\", function (m, off) {\n    return off >= r2 ? \"\" : \"ative\";\n  }]); // Step 4\n\n  word = stemmer.among(word, r2, [\"(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ism|ate|iti|ous|ive|ize)\", \"\", \"ion\", function (m, off) {\n    return ~\"st\".indexOf(word[off - 1]) ? \"\" : m;\n  }]); // Step 5\n\n  word = stemmer.among(word, r1, [\"e\", function (m, off) {\n    return off >= r2 || !shortv(word, off - 2) ? \"\" : \"e\";\n  }, \"l\", function (m, off) {\n    return word[off - 1] === \"l\" && off >= r2 ? \"\" : \"l\";\n  }]);\n  word = word.replace(/Y/g, \"y\");\n  return word;\n}; // Check for a short syllable at the given index.\n// Examples:\n//\n//   rap\n//   trap\n//   entrap\n//\n// NOT short\n//\n//   uproot\n//   bestow\n//   disturb\n//\n\n\nfunction shortv(word, i) {\n  if (i == null) i = word.length - 2;\n  if (word.length < 3) i = 0; //return true\n\n  return !!(!~vowels.indexOf(word[i - 1]) && ~vowels.indexOf(word[i]) && !~v_wxy.indexOf(word[i + 1]) || i === 0 && ~vowels.indexOf(word[i]) && !~vowels.indexOf(word[i + 1]));\n} // Check if the word is short.\n\n\nfunction short(word, r1) {\n  var l = word.length;\n  return r1 >= l && shortv(word, l - 2);\n}","map":null,"metadata":{},"sourceType":"script"}